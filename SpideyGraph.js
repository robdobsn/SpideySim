// Generated by CoffeeScript 1.8.0
(function() {
  var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  this.SpideyGraph = (function() {
    function SpideyGraph() {}

    SpideyGraph.prototype.padAdjacencies = [];

    SpideyGraph.prototype.maxDistForPadAdjacency = 300;

    SpideyGraph.prototype.maxDistForLedAdjacency = 10;

    SpideyGraph.prototype.maxDistForNodeDetect = 11;

    SpideyGraph.prototype.maxDistForNodeMerge = 10;

    SpideyGraph.prototype.genColours = function(numColours) {
      var colourList, colrStr, hslColour, i, _i, _ref;
      colourList = [];
      for (i = _i = 0, _ref = 360 / numColours; _i < 360; i = _i += _ref) {
        hslColour = d3.hsl((i * 1787) % 360, 0.90 + Math.random() * 0.10, 0.50 + Math.random() * 0.10);
        colrStr = hslColour.toString();
        colourList.push(colrStr);
      }
      return colourList;
    };

    SpideyGraph.prototype.dist = function(led1, led2) {
      var dx, dy;
      dx = led1.pt.x - led2.pt.x;
      dy = led1.pt.y - led2.pt.y;
      return Math.sqrt(dx * dx + dy * dy);
    };

    SpideyGraph.prototype.getCofGforLeds = function(padLedsData, ledList) {
      var ledId, xSum, ySum, _i, _len;
      xSum = 0;
      ySum = 0;
      for (_i = 0, _len = ledList.length; _i < _len; _i++) {
        ledId = ledList[_i];
        xSum += padLedsData[ledId[0]][ledId[1]].pt.x;
        ySum += padLedsData[ledId[0]][ledId[1]].pt.y;
      }
      return {
        pt: {
          x: xSum / ledList.length,
          y: ySum / ledList.length
        }
      };
    };

    SpideyGraph.prototype.createGraph = function(padOutlines, padLedsData, svg) {
      var adjFound, alreadInList, colrIdx, colrs, curCofG, discardFree, edge, edgeList, edgesSvg, edgesTo, freeLedList, freeLeds, freeNodeLeds, freeRationalisedList, fromNode, fullNode, fullNodeList, led, ledAdjList, ledIdx, ledInfo, ledPadFound, ledUniqPads, listMerged, node, nodeAlreadyInList, nodeIdx, nodeLed, nodeLedList, nodeLeds, nodeLedsIdx, nodeRationalisedList, nodesSvg, otherLedIdx, otherLedInfo, otherNodeLed, otherNodeLedsIdx, otherPadIdx, otherPadLedsInfo, padAdjList, padIdx, padLedsInfo, testNode, testNodeIdx, testNodeLeds, thisNode, _aa, _ab, _ac, _ad, _ae, _af, _ag, _ah, _i, _j, _k, _l, _len, _len1, _len10, _len11, _len12, _len13, _len14, _len15, _len16, _len17, _len18, _len19, _len2, _len20, _len21, _len22, _len23, _len3, _len4, _len5, _len6, _len7, _len8, _len9, _m, _n, _o, _p, _q, _r, _ref, _ref1, _ref10, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9, _s, _t, _u, _v, _w, _x, _y, _z;
      for (padIdx = _i = 0, _len = padLedsData.length; _i < _len; padIdx = ++_i) {
        padLedsInfo = padLedsData[padIdx];
        this.padAdjacencies.push([]);
        for (otherPadIdx = _j = 0, _ref = padLedsData.length; 0 <= _ref ? _j < _ref : _j > _ref; otherPadIdx = 0 <= _ref ? ++_j : --_j) {
          if (padIdx === otherPadIdx) {
            continue;
          }
          otherPadLedsInfo = padLedsData[otherPadIdx];
          if (this.dist(padLedsInfo[0], otherPadLedsInfo[0]) > this.maxDistForPadAdjacency) {
            continue;
          }
          adjFound = false;
          for (ledIdx = _k = 0, _len1 = padLedsInfo.length; _k < _len1; ledIdx = ++_k) {
            ledInfo = padLedsInfo[ledIdx];
            if (this.dist(ledInfo, otherPadLedsInfo[0]) > this.maxDistForPadAdjacency) {
              continue;
            }
            for (otherLedIdx = _l = 0, _len2 = otherPadLedsInfo.length; _l < _len2; otherLedIdx = ++_l) {
              otherLedInfo = otherPadLedsInfo[otherLedIdx];
              if (this.dist(ledInfo, otherLedInfo) < this.maxDistForLedAdjacency) {
                adjFound = true;
                this.padAdjacencies[padIdx].push(otherPadIdx);
                break;
              }
            }
            if (adjFound) {
              break;
            }
          }
        }
      }
      nodeLedList = [];
      freeLedList = [];
      _ref1 = this.padAdjacencies;
      for (padIdx = _m = 0, _len3 = _ref1.length; _m < _len3; padIdx = ++_m) {
        padAdjList = _ref1[padIdx];
        _ref2 = padLedsData[padIdx];
        for (ledIdx = _n = 0, _len4 = _ref2.length; _n < _len4; ledIdx = ++_n) {
          ledInfo = _ref2[ledIdx];
          ledAdjList = [];
          ledUniqPads = 0;
          for (_o = 0, _len5 = padAdjList.length; _o < _len5; _o++) {
            otherPadIdx = padAdjList[_o];
            ledPadFound = false;
            _ref3 = padLedsData[otherPadIdx];
            for (otherLedIdx = _p = 0, _len6 = _ref3.length; _p < _len6; otherLedIdx = ++_p) {
              otherLedInfo = _ref3[otherLedIdx];
              if (this.dist(ledInfo, otherLedInfo) < this.maxDistForNodeDetect) {
                if (ledAdjList.length === 0) {
                  ledAdjList.push([padIdx, ledIdx]);
                }
                ledAdjList.push([otherPadIdx, otherLedIdx]);
                if (!ledPadFound) {
                  ledUniqPads++;
                  ledPadFound = true;
                }
              }
            }
          }
          if (ledUniqPads >= 2) {
            nodeAlreadyInList = false;
            for (_q = 0, _len7 = nodeLedList.length; _q < _len7; _q++) {
              nodeLeds = nodeLedList[_q];
              for (_r = 0, _len8 = nodeLeds.length; _r < _len8; _r++) {
                led = nodeLeds[_r];
                if (led[0] === padIdx) {
                  if (led[1] === ledIdx) {
                    nodeAlreadyInList = true;
                    break;
                  }
                }
              }
              if (nodeAlreadyInList) {
                break;
              }
            }
            if (!nodeAlreadyInList) {
              nodeLedList.push(ledAdjList);
            }
          } else {
            if (ledIdx === 0 || ledIdx === padLedsData[padIdx].length - 1) {
              freeLedList.push(ledAdjList);
            }
          }
        }
      }
      nodeRationalisedList = [];
      for (nodeLedsIdx = _s = 0, _len9 = nodeLedList.length; _s < _len9; nodeLedsIdx = ++_s) {
        nodeLeds = nodeLedList[nodeLedsIdx];
        curCofG = this.getCofGforLeds(padLedsData, nodeLeds);
        for (otherNodeLedsIdx = _t = _ref4 = nodeLedsIdx + 1, _ref5 = nodeLedList.length; _ref4 <= _ref5 ? _t < _ref5 : _t > _ref5; otherNodeLedsIdx = _ref4 <= _ref5 ? ++_t : --_t) {
          listMerged = false;
          if (this.dist(curCofG, this.getCofGforLeds(padLedsData, nodeLedList[otherNodeLedsIdx])) < this.maxDistForNodeMerge) {
            for (_u = 0, _len10 = nodeLeds.length; _u < _len10; _u++) {
              nodeLed = nodeLeds[_u];
              alreadInList = false;
              _ref6 = nodeLedList[otherNodeLedsIdx];
              for (_v = 0, _len11 = _ref6.length; _v < _len11; _v++) {
                otherNodeLed = _ref6[_v];
                if (nodeLed[0] === otherNodeLed[0] && nodeLed[1] === otherNodeLed[1]) {
                  alreadInList = true;
                }
              }
              if (!alreadInList) {
                nodeLedList[otherNodeLedsIdx].push(nodeLed);
              }
            }
            listMerged = true;
            break;
          }
        }
        if (!listMerged) {
          nodeRationalisedList.push({
            leds: nodeLeds,
            CofG: this.getCofGforLeds(padLedsData, nodeLeds),
            nodeDegree: 2
          });
        }
      }
      freeRationalisedList = [];
      for (nodeLedsIdx = _w = 0, _len12 = freeLedList.length; _w < _len12; nodeLedsIdx = ++_w) {
        freeNodeLeds = freeLedList[nodeLedsIdx];
        curCofG = this.getCofGforLeds(padLedsData, freeNodeLeds);
        discardFree = false;
        for (_x = 0, _len13 = nodeRationalisedList.length; _x < _len13; _x++) {
          nodeLeds = nodeRationalisedList[_x];
          if (this.dist(curCofG, this.getCofGforLeds(padLedsData, nodeLeds.leds)) < this.maxDistForNodeMerge) {
            discardFree = true;
            break;
          }
        }
        for (_y = 0, _len14 = freeRationalisedList.length; _y < _len14; _y++) {
          freeLeds = freeRationalisedList[_y];
          if (this.dist(curCofG, this.getCofGforLeds(padLedsData, freeLeds.leds)) < this.maxDistForNodeMerge) {
            discardFree = true;
            break;
          }
        }
        if (!discardFree) {
          freeRationalisedList.push({
            leds: freeNodeLeds,
            CofG: this.getCofGforLeds(padLedsData, freeNodeLeds),
            nodeDegree: 1
          });
        }
      }
      fullNodeList = nodeRationalisedList.concat(freeRationalisedList);
      console.log("InnerNodeList " + nodeRationalisedList.length);
      console.log("FreeNodeList " + freeRationalisedList.length);
      console.log("FullNodeList " + fullNodeList.length);
      for (_z = 0, _len15 = fullNodeList.length; _z < _len15; _z++) {
        fullNode = fullNodeList[_z];
        fullNode.edgesTo = [];
      }
      _ref7 = this.padAdjacencies;
      for (padIdx = _aa = 0, _len16 = _ref7.length; _aa < _len16; padIdx = ++_aa) {
        padAdjList = _ref7[padIdx];
        fromNode = -1;
        _ref8 = padLedsData[padIdx];
        for (ledIdx = _ab = 0, _len17 = _ref8.length; _ab < _len17; ledIdx = ++_ab) {
          ledInfo = _ref8[ledIdx];
          thisNode = -1;
          for (testNodeIdx = _ac = 0, _len18 = fullNodeList.length; _ac < _len18; testNodeIdx = ++_ac) {
            testNode = fullNodeList[testNodeIdx];
            _ref9 = testNode.leds;
            for (_ad = 0, _len19 = _ref9.length; _ad < _len19; _ad++) {
              testNodeLeds = _ref9[_ad];
              if (testNodeLeds[0] === padIdx && testNodeLeds[1] === ledIdx) {
                thisNode = testNodeIdx;
                break;
              }
            }
            if (thisNode !== -1) {
              break;
            }
          }
          if (fromNode !== -1 && thisNode !== -1 && thisNode !== fromNode) {
            if (__indexOf.call(fullNodeList[fromNode].edgesTo, thisNode) < 0) {
              fullNodeList[fromNode].edgesTo.push(thisNode);
            }
            if (__indexOf.call(fullNodeList[thisNode].edgesTo, fromNode) < 0) {
              fullNodeList[thisNode].edgesTo.push(fromNode);
            }
          }
          if (thisNode !== -1) {
            fromNode = thisNode;
          }
        }
      }
      edgeList = [];
      for (nodeIdx = _ae = 0, _len20 = fullNodeList.length; _ae < _len20; nodeIdx = ++_ae) {
        node = fullNodeList[nodeIdx];
        _ref10 = node.edgesTo;
        for (_af = 0, _len21 = _ref10.length; _af < _len21; _af++) {
          edgesTo = _ref10[_af];
          edgeList.push({
            from: {
              nodeIdx: nodeIdx,
              pt: node.CofG.pt
            },
            to: {
              nodeIdx: edgesTo,
              pt: fullNodeList[edgesTo].CofG.pt
            }
          });
        }
      }
      colrs = this.genColours(fullNodeList.length);
      colrIdx = 0;
      console.log("NumNodes = " + fullNodeList.length);
      for (_ag = 0, _len22 = fullNodeList.length; _ag < _len22; _ag++) {
        nodeLeds = fullNodeList[_ag];
        nodeLeds.colr = colrs[colrIdx++];
      }
      fullNodeList[0].colr = "#000000";
      nodesSvg = svg.selectAll("g.nodes").data(fullNodeList).enter().append("g").attr("class", "nodes").append("circle").attr("class", "node").attr("cx", function(d) {
        return d.CofG.pt.x;
      }).attr("cy", function(d) {
        return d.CofG.pt.y;
      }).attr("r", 5).attr("fill", function(d, i) {
        return d.colr;
      });
      for (_ah = 0, _len23 = edgeList.length; _ah < _len23; _ah++) {
        edge = edgeList[_ah];
        console.log("edge from " + edge.from.nodeIdx + ", to " + edge.to.nodeIdx);
      }
      return edgesSvg = svg.selectAll("g.edges").data(edgeList).enter().append("g").attr("class", "edges").append("line").attr("class", "edge").attr("x1", function(d) {
        console.log(d);
        return d.from.pt.x;
      }).attr("y1", function(d) {
        return d.from.pt.y;
      }).attr("x2", function(d) {
        return d.to.pt.x;
      }).attr("y2", function(d) {
        return d.to.pt.y;
      }).attr("stroke", function(d, i) {
        return 'black';
      });
    };

    return SpideyGraph;

  })();

}).call(this);
