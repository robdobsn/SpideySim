// Generated by CoffeeScript 1.8.0
var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

this.spideyGeom = (function() {
  function spideyGeom() {
    this.stepFn = __bind(this.stepFn, this);
    this.pacManStep = __bind(this.pacManStep, this);
  }

  spideyGeom.prototype.ledInterval = 6.9;

  spideyGeom.prototype.steps = 0;

  spideyGeom.prototype.ledUISize = 3;

  spideyGeom.prototype.padInfo = [
    {
      chainIdx: 780,
      startPos: 0,
      endPos: -1,
      hiddenLeds: 47,
      anticlockwise: true
    }, {
      chainIdx: 540,
      startPos: 0.35,
      endPos: 0.99,
      hiddenLeds: 0,
      anticlockwise: true
    }, {
      chainIdx: 878,
      startPos: 0,
      endPos: -1,
      hiddenLeds: 17,
      anticlockwise: true
    }, {
      chainIdx: 1180,
      startPos: 0,
      endPos: 0.71,
      hiddenLeds: 0,
      anticlockwise: true
    }, {
      chainIdx: 1086,
      startPos: 0,
      endPos: -1,
      hiddenLeds: 9,
      anticlockwise: true
    }, {
      chainIdx: 0,
      startPos: 0,
      endPos: -1,
      hiddenLeds: 7,
      anticlockwise: true
    }, {
      chainIdx: 678,
      startPos: 0,
      endPos: -1,
      hiddenLeds: 42,
      anticlockwise: true
    }, {
      chainIdx: 1260,
      startPos: 0,
      endPos: -1,
      hiddenLeds: 34,
      anticlockwise: true
    }, {
      chainIdx: 628,
      startPos: 0,
      endPos: -1,
      hiddenLeds: -32,
      anticlockwise: true
    }, {
      chainIdx: 222,
      startPos: 0,
      endPos: -1,
      hiddenLeds: -7,
      anticlockwise: true
    }, {
      chainIdx: 276,
      startPos: 0,
      endPos: -1,
      hiddenLeds: -27,
      anticlockwise: true
    }, {
      chainIdx: 1414,
      startPos: 0,
      endPos: -0.98,
      hiddenLeds: 30,
      anticlockwise: true
    }, {
      chainIdx: 174,
      startPos: 0,
      endPos: -1,
      hiddenLeds: 37,
      anticlockwise: true
    }, {
      chainIdx: 579,
      startPos: 0,
      endPos: -1,
      hiddenLeds: 36,
      anticlockwise: true
    }, {
      chainIdx: 1134,
      startPos: 0,
      endPos: -0.99,
      hiddenLeds: 10,
      anticlockwise: true
    }, {
      chainIdx: 323,
      startPos: 0.36,
      endPos: 0.98,
      hiddenLeds: 0,
      anticlockwise: true
    }, {
      chainIdx: 386,
      startPos: 0,
      endPos: -1,
      hiddenLeds: -38,
      anticlockwise: true
    }, {
      chainIdx: 431,
      startPos: 0,
      endPos: -1,
      hiddenLeds: 13,
      anticlockwise: true
    }, {
      chainIdx: 1524,
      startPos: 0,
      endPos: -0.98,
      hiddenLeds: 27,
      anticlockwise: true
    }, {
      chainIdx: 1556,
      startPos: 0,
      endPos: -0.96,
      hiddenLeds: 32,
      anticlockwise: true
    }, {
      chainIdx: 94,
      startPos: 0,
      endPos: -1,
      hiddenLeds: -26,
      anticlockwise: true
    }, {
      chainIdx: 132,
      startPos: 0,
      endPos: -1,
      hiddenLeds: -5,
      anticlockwise: true
    }, {
      chainIdx: 1609,
      startPos: 0.2,
      endPos: 1.0,
      hiddenLeds: 0,
      anticlockwise: false
    }, {
      chainIdx: 1472,
      startPos: 0.34,
      endPos: 0.98,
      hiddenLeds: 0,
      anticlockwise: false
    }, {
      chainIdx: 348,
      startPos: 0,
      endPos: -1,
      hiddenLeds: 8,
      anticlockwise: true
    }, {
      chainIdx: 1590,
      startPos: 0.02,
      endPos: 0.49,
      hiddenLeds: 0,
      anticlockwise: true
    }, {
      chainIdx: 1637,
      startPos: 0.25,
      endPos: 1.0,
      hiddenLeds: 0,
      anticlockwise: false
    }, {
      chainIdx: 1304,
      startPos: 0.01,
      endPos: 0.70,
      hiddenLeds: 0,
      anticlockwise: true
    }, {
      chainIdx: 308,
      startPos: 0.01,
      endPos: 0.51,
      hiddenLeds: 14,
      anticlockwise: true
    }, {
      chainIdx: 466,
      startPos: 0.01,
      endPos: 0.64,
      hiddenLeds: 0,
      anticlockwise: true
    }, {
      chainIdx: 1665,
      startPos: 0.02,
      endPos: 0.55,
      hiddenLeds: 0,
      anticlockwise: true
    }, {
      chainIdx: 1498,
      startPos: 0.37,
      endPos: 1.00,
      hiddenLeds: 0,
      anticlockwise: false
    }, {
      chainIdx: 1448,
      startPos: 0.35,
      endPos: 0.98,
      hiddenLeds: 0,
      anticlockwise: false
    }, {
      chainIdx: 732,
      startPos: 0,
      endPos: -0.98,
      hiddenLeds: 34,
      anticlockwise: true
    }, {
      chainIdx: 1346,
      startPos: 0.37,
      endPos: 1.00,
      hiddenLeds: 0,
      anticlockwise: false
    }, {
      chainIdx: 1220,
      startPos: 0.01,
      endPos: 0.72,
      hiddenLeds: 0,
      anticlockwise: true
    }, {
      chainIdx: 1376,
      startPos: 0,
      endPos: -1,
      hiddenLeds: -27,
      anticlockwise: true
    }, {
      chainIdx: 56,
      startPos: 0,
      endPos: -1,
      hiddenLeds: 30,
      anticlockwise: true
    }, {
      chainIdx: 516,
      startPos: 0.01,
      endPos: 0.55,
      hiddenLeds: 0,
      anticlockwise: true
    }, {
      chainIdx: 836,
      startPos: 0.02,
      endPos: 0.68,
      hiddenLeds: 0,
      anticlockwise: true
    }, {
      chainIdx: 1040,
      startPos: 0,
      endPos: -1,
      hiddenLeds: 39,
      anticlockwise: true
    }, {
      chainIdx: 1000,
      startPos: 0.01,
      endPos: 0.73,
      hiddenLeds: 0,
      anticlockwise: true
    }, {
      chainIdx: 934,
      startPos: 0.03,
      endPos: 0.78,
      hiddenLeds: 0,
      anticlockwise: true
    }, {
      chainIdx: 974,
      startPos: 0.2,
      endPos: 0.69,
      hiddenLeds: 0,
      anticlockwise: true
    }, {
      chainIdx: 490,
      startPos: 0.01,
      endPos: 0.67,
      hiddenLeds: 0,
      anticlockwise: true
    }
  ];

  spideyGeom.prototype.init = function() {
    var led, ledCount, ledsChain, padLedsData, svg, text, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
    this.spideyAnim = new SpideyAnimation();
    this.spideyGraph = new SpideyGraph();
    this.spideyPacMan = new SpideyPacMan(this);
    svg = d3.select("#spideyGeom svg");
    this.padOutlines = svg.selectAll("path");
    this.pad_centers = this.padOutlines[0].map(function(d, padIdx) {
      var bbox;
      bbox = d.getBBox();
      return [bbox.x + bbox.width / 2, bbox.y + bbox.height / 2, padIdx];
    });
    this.padLedsList = this.padOutlines[0].map((function(_this) {
      return function(d, padIdx) {
        var chainIdx, intv, ledIdx, ledOffset, ledReversed, leds, numLeds, pDist, pPos, pathLen, pathStart, stripLen, wrapRound;
        pathLen = d.getTotalLength();
        wrapRound = _this.padInfo[padIdx].endPos < 0;
        stripLen = pathLen * Math.abs(_this.padInfo[padIdx].endPos - _this.padInfo[padIdx].startPos);
        intv = _this.ledInterval;
        pathStart = pathLen * _this.padInfo[padIdx].startPos;
        if (_this.padInfo[padIdx].anticlockwise) {
          intv = -_this.ledInterval;
          pathStart = pathLen * (1 - _this.padInfo[padIdx].startPos);
        }
        numLeds = Math.floor((stripLen / _this.ledInterval) + 0.5);
        leds = [];
        pPos = pathStart;
        pDist = 0;
        ledIdx = 0;
        ledOffset = Math.abs(_this.padInfo[padIdx].hiddenLeds);
        ledReversed = _this.padInfo[padIdx].hiddenLeds < 0;
        while (true) {
          if (pDist >= stripLen - (_this.ledInterval / 2)) {
            break;
          }
          chainIdx = _this.padInfo[padIdx].chainIdx + (2 * numLeds + (ledReversed ? -ledIdx : ledIdx) - ledOffset) % numLeds;
          leds.push({
            pt: d.getPointAtLength(pPos),
            padIdx: padIdx,
            ledIdx: ledIdx,
            clr: "#d4d4d4",
            chainIdx: chainIdx
          });
          pDist += _this.ledInterval;
          pPos += intv;
          ledIdx++;
          if (wrapRound) {
            if (pPos > pathLen || pPos < 0) {
              pPos = pPos + (intv > 0 ? -pathLen : pathLen);
            }
          }
        }
        return leds;
      };
    })(this));
    ledCount = 0;
    _ref = this.padLedsList;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      padLedsData = _ref[_i];
      ledCount += padLedsData.length;
    }
    console.log("Total Leds = " + ledCount);
    _ref1 = this.padLedsList;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      padLedsData = _ref1[_j];
      padLedsData[0].clr = "#000000";
    }
    this.padLeds = svg.selectAll("g.padLeds").data(this.padLedsList).enter().append("g").attr("class", "padLeds");
    this.ledsSel = this.padLeds.selectAll(".led").data(function(d, i) {
      return d;
    }).enter().append("circle").attr("class", "led").attr("cx", function(d) {
      return d.pt.x;
    }).attr("cy", function(d) {
      return d.pt.y;
    }).attr("r", this.ledUISize).attr("fill", function(d, i) {
      return d.clr;
    }).text(function(d, i) {
      return d.chainIdx + " ";
    });
    text = svg.selectAll("text").data(this.pad_centers).enter().append("text");
    text.attr("x", function(d) {
      return d[0] - 10;
    }).attr("y", function(d) {
      return d[1] + 8;
    }).text(function(d) {
      return d[2];
    }).attr("font-family", "sans-serif").attr("font-size", "20px").attr("fill", "#DCDCDC");
    this.spideyGraph.createGraph(this.padOutlines, this.padLedsList, this.ledsSel, svg);
    this.showDownloadJsonLink();
    this.spideyGraph.colourNodes();
    this.spideyGraph.displayEdges();
    this.spideyGraph.labelNodes();
    this.spideyTimer = setInterval(this.pacManStep, 200);
    clearInterval(this.spideyTimer);
    $("#startSpidey").click((function(_this) {
      return function() {
        clearInterval(_this.spideyTimer);
        _this.spideyTimer = setInterval(_this.pacManStep, 200);
        return _this.showDebug();
      };
    })(this));
    $("#pauseSpidey").click((function(_this) {
      return function() {
        return clearInterval(_this.spideyTimer);
      };
    })(this));
    $("#steprightSpidey").click((function(_this) {
      return function() {
        _this.spideyPacMan.mouseover('right');
        return _this.pacManStep();
      };
    })(this));
    $("#stepleftSpidey").click((function(_this) {
      return function() {
        _this.spideyPacMan.mouseover('left');
        return _this.pacManStep();
      };
    })(this));
    $("#stepSpidey").click((function(_this) {
      return function() {
        _this.spideyPacMan.mouseover('forward');
        return _this.pacManStep();
      };
    })(this));
    $("#stepbackSpidey").click((function(_this) {
      return function() {
        _this.spideyPacMan.mouseover('back');
        return _this.pacManStep();
      };
    })(this));
    $("#moveup").mousemove((function(_this) {
      return function() {
        return _this.spideyPacMan.mouseover('forward');
      };
    })(this));
    $("#movedown").mousemove((function(_this) {
      return function() {
        return _this.spideyPacMan.mouseover('back');
      };
    })(this));
    $("#moveleft").mousemove((function(_this) {
      return function() {
        return _this.spideyPacMan.mouseover('left');
      };
    })(this));
    $("#moveright").mousemove((function(_this) {
      return function() {
        return _this.spideyPacMan.mouseover('right');
      };
    })(this));
    $(".led").mousemove((function(_this) {
      return function(ev) {
        var ledIdx, ledInfo;
        ledIdx = parseInt(ev.currentTarget.textContent);
        ledInfo = _this.ledsChainList[ledIdx];
        return $("#DebugInfo3").text(ev.currentTarget.textContent + " P" + ledInfo.padIdx + " PL" + ledInfo.ledIdx);
      };
    })(this));
    this.ledsSel.attr("fill", function(d) {
      return d.clr;
    });
    ledsChain = this.flatten_array(this.padLedsList);
    this.ledsChainList = [];
    for (_k = 0, _len2 = ledsChain.length; _k < _len2; _k++) {
      led = ledsChain[_k];
      this.ledsChainList[led.chainIdx] = led;
    }
  };

  spideyGeom.prototype.pacManStep = function() {
    this.spideyPacMan.step();
    return this.showDebug();
  };

  spideyGeom.prototype.showDebug = function() {
    var dbg;
    dbg = this.spideyPacMan.getDebugInfo();
    $('#DebugInfo').text(dbg);
  };

  spideyGeom.prototype.d2h = function(d) {
    return d.toString(16);
  };

  spideyGeom.prototype.h2d = function(h) {
    return parseInt(h, 16);
  };

  spideyGeom.prototype.zeropad = function(n, width, z) {
    z = z || '0';
    n = n + '';
    if (n.length >= width) {
      return n;
    } else {
      return new Array(width - n.length + 1).join(z) + n;
    }
  };

  spideyGeom.prototype.execSpideyCmd = function(cmdParams) {
    console.log("Sending " + cmdParams);
    $.ajax(cmdParams, {
      type: "GET",
      dataType: "text",
      success: (function(_this) {
        return function(data, textStatus, jqXHR) {};
      })(this),
      error: (function(_this) {
        return function(jqXHR, textStatus, errorThrown) {
          return console.error("Direct exec command failed: " + textStatus + " " + errorThrown + " COMMAND=" + cmdParams);
        };
      })(this)
    });
  };

  spideyGeom.prototype.sendLedCmd = function(ledChainIdx, ledclr) {
    var clrStr;
    clrStr = ledclr === "white" ? "000000" : "800000";
    if (ledclr !== "white") {
      this.ipCmdBuf += "000802" + this.zeropad(this.d2h(ledChainIdx), 4) + "0001" + clrStr;
    }
  };

  spideyGeom.prototype.setNodeColour = function(nodeIdx, disp, colour) {
    var dbg, node, nodeLed, _i, _len, _ref;
    node = this.spideyGraph.nodeList[nodeIdx];
    dbg = "";
    _ref = node.leds;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      nodeLed = _ref[_i];
      if (disp) {
        nodeLed.led.clr = colour;
      } else {
        nodeLed.led.clr = "white";
      }
      this.sendLedCmd(nodeLed.led.chainIdx, nodeLed.led.clr);
      dbg += "P" + nodeLed.padIdx + " X" + nodeLed.ledIdx + " C" + nodeLed.led.chainIdx + ", ";
    }
    $('#DebugInfo2').text(dbg);
  };

  spideyGeom.prototype.setLinkColour = function(nodeIdx, linkIdx, linkStep, disp, colour) {
    var dbg, edgeLeds, led, link, node, _i, _len, _ref;
    node = this.spideyGraph.nodeList[nodeIdx];
    link = node.edgesTo[linkIdx];
    dbg = "";
    if (linkStep < link.edgeList.length) {
      _ref = link.edgeList[linkStep];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        edgeLeds = _ref[_i];
        led = edgeLeds.led;
        dbg += "P" + led.padIdx + " X" + led.ledIdx + " C" + led.chainIdx + ", ";
        if (disp) {
          led.clr = colour;
        } else {
          led.clr = "white";
        }
        this.sendLedCmd(led.chainIdx, led.clr);
      }
    } else {
      dbg = "ListLenErr";
    }
    $('#DebugInfo2').text(dbg);
  };

  spideyGeom.prototype.getNodeXY = function(nodeIdx) {
    return this.spideyGraph.nodeList[nodeIdx].CofG.pt;
  };

  spideyGeom.prototype.getLinkLedXY = function(nodeIdx, linkIdx, linkStep) {
    return this.spideyGraph.nodeList[nodeIdx].edgesTo[linkIdx].edgeList[linkStep][0].led.pt;
  };

  spideyGeom.prototype.getNumLinks = function(nodeIdx) {
    return this.spideyGraph.nodeList[nodeIdx].edgesTo.length;
  };

  spideyGeom.prototype.getLinkLength = function(nodeIdx, linkIdx) {
    return this.spideyGraph.nodeList[nodeIdx].edgesTo[linkIdx].edgeList.length;
  };

  spideyGeom.prototype.getLinkTarget = function(nodeIdx, linkIdx) {
    return this.spideyGraph.nodeList[nodeIdx].edgesTo[linkIdx].toNodeIdx;
  };

  spideyGeom.prototype.preShowAll = function() {
    return this.ipCmdBuf = "";
  };

  spideyGeom.prototype.showAll = function() {
    this.ledsSel.attr("fill", function(d) {
      return d.clr;
    });
    this.ipCmdBuf = "0000000101" + this.ipCmdBuf + "00";
    this.execSpideyCmd("http://macallan:5078/rawcmd/" + this.ipCmdBuf);
  };

  spideyGeom.prototype.stepFn = function() {
    var ledData, padLedsData, _i, _j, _len, _len1, _ref;
    this.steps++;
    if (this.steps > 1000) {
      return true;
    }
    _ref = this.padLedsList;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      padLedsData = _ref[_i];
      for (_j = 0, _len1 = padLedsData.length; _j < _len1; _j++) {
        ledData = padLedsData[_j];
        ledData.clr = this.spideyAnim.getColour(ledData.pt.x, ledData.pt.y, ledData.padIdx, ledData.ledIdx, this.steps);
      }
    }
    this.ledsSel.attr("fill", function(d) {
      return d.clr;
    });
    return false;
  };

  spideyGeom.prototype.getNodeExportInfo = function(node) {
    var edgeTo, nodeLed, rtnData;
    rtnData = {
      x: node.CofG.pt.x,
      y: node.CofG.pt.y,
      nodeDegree: node.nodeDegree,
      name: node.nodeId,
      ledIdxs: (function() {
        var _i, _len, _ref, _results;
        _ref = node.leds;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          nodeLed = _ref[_i];
          _results.push(nodeLed.led.chainIdx);
        }
        return _results;
      })(),
      linkIdxs: (function() {
        var _i, _len, _ref, _results;
        _ref = node.edgesTo;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          edgeTo = _ref[_i];
          _results.push(edgeTo.linkListIdx);
        }
        return _results;
      })()
    };
    return rtnData;
  };

  spideyGeom.prototype.angle = function(x1, y1, x2, y2) {
    return Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
  };

  spideyGeom.prototype.getLinkExportInfo = function() {
    var edgeTo, node, oneLink, rtnData, toNode, _i, _j, _len, _len1, _ref, _ref1;
    rtnData = [];
    _ref = this.spideyGraph.nodeList;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      node = _ref[_i];
      _ref1 = node.edgesTo;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        edgeTo = _ref1[_j];
        edgeTo.linkListIdx = rtnData.length;
        toNode = this.spideyGraph.nodeList[edgeTo.toNodeIdx];
        oneLink = {
          linkIdx: rtnData.length,
          source: node.nodeId,
          xSource: node.CofG.pt.x,
          ySource: node.CofG.pt.y,
          target: edgeTo.toNodeIdx,
          xTarget: toNode.CofG.pt.x,
          yTarget: toNode.CofG.pt.y,
          linkAngle: this.angle(node.CofG.pt.x, node.CofG.pt.y, toNode.CofG.pt.x, toNode.CofG.pt.y),
          padEdges: edgeTo.edgeLedsList
        };
        rtnData.push(oneLink);
      }
    }
    return rtnData;
  };

  spideyGeom.prototype.flatten_array = function(a) {
    if (a == null) {
      return null;
    } else if (a.length === 0) {
      return [];
    } else {
      return a.reduce(function(l, r) {
        return l.concat(r);
      });
    }
  };

  spideyGeom.prototype.getLedsExportInfo = function() {
    var finalLeds, led, ledIdx, leds, newLed, _i, _j, _len, _len1;
    leds = this.flatten_array(this.padLedsList);
    finalLeds = [];
    for (_i = 0, _len = leds.length; _i < _len; _i++) {
      led = leds[_i];
      newLed = {
        x: led.pt.x,
        y: led.pt.y,
        ledIdx: led.chainIdx,
        padIdx: led.padIdx
      };
      finalLeds[led.chainIdx] = newLed;
    }
    for (ledIdx = _j = 0, _len1 = finalLeds.length; _j < _len1; ledIdx = ++_j) {
      led = finalLeds[ledIdx];
      if (led == null) {
        finalLeds[ledIdx] = {
          x: 0,
          y: 0,
          ledIdx: -1,
          padIdx: -1
        };
      }
    }
    return finalLeds;
  };

  spideyGeom.prototype.getPadsExportInfo = function() {
    var led, leds, padCentre, padIdx, padInfo, padLeds, padsList, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
    padsList = [];
    _ref = this.pad_centers;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      padCentre = _ref[_i];
      padInfo = {
        x: padCentre[0],
        y: padCentre[1]
      };
      padsList.push(padInfo);
    }
    _ref1 = this.padLedsList;
    for (padIdx = _j = 0, _len1 = _ref1.length; _j < _len1; padIdx = ++_j) {
      padLeds = _ref1[padIdx];
      leds = [];
      for (_k = 0, _len2 = padLeds.length; _k < _len2; _k++) {
        led = padLeds[_k];
        leds.push(led.chainIdx);
      }
      padsList[padIdx].ledIdxs = leds;
      padsList[padIdx].padIdx = padIdx;
    }
    return padsList;
  };

  spideyGeom.prototype.convLedListForPad = function(ledList) {
    if (ledList.length === 0) {
      return "{ -1, -1 },";
    }
    ledList.sort(function(a, b) {
      return a - b;
    });
    return "{ " + ledList[0] + ", " + ledList[ledList.length - 1] + " },";
  };

  spideyGeom.prototype.convertPadsToMbedHeader = function(spideyGeomToExport) {
    var outLine, outText, pad, _i, _len, _ref;
    outText = "";
    outLine = "// Spidey pads\n\nstruct SpideyPadInfo\n{\n	int padLeds[2];\n};\n\nstatic const SpideyPadInfo _spideyPads[] =\n{\n";
    _ref = spideyGeomToExport.pads;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      pad = _ref[_i];
      outLine += "\t" + this.convLedListForPad(pad.ledIdxs) + "\n";
    }
    outLine += "};\n";
    outText += outLine;
    return outText;
  };

  spideyGeom.prototype.convLedListToMbedSeq = function(ledList) {
    var edgeLen, lastLed, led, ledIdx, ledSeqText, seqLen, _i, _len, _ref;
    edgeLen = 0;
    if ((ledList == null) || ledList.ledIdxs.length === 0) {
      return [edgeLen, "{ -1, -1 }"];
    }
    lastLed = -10;
    seqLen = 1;
    ledSeqText = "{ ";
    _ref = ledList.ledIdxs;
    for (ledIdx = _i = 0, _len = _ref.length; _i < _len; ledIdx = ++_i) {
      led = _ref[ledIdx];
      if (ledIdx === 0) {
        ledSeqText += "" + led + ", ";
      } else if ((led + 1 !== lastLed) && (led - 1 !== lastLed)) {
        ledSeqText += "" + lastLed + ", " + led + ", ";
        seqLen += 1;
      }
      if (ledIdx === ledList.ledIdxs.length - 1) {
        ledSeqText += "" + led + " ";
      }
      lastLed = led;
    }
    ledSeqText += " }";
    if (seqLen > 2) {
      console.log("Seq Length > 2 ==== " + seqLen);
    }
    return [ledList.ledIdxs.length, ledSeqText];
  };

  spideyGeom.prototype.convNodeToMbedSeq = function(node, spideyGeomToExport) {
    var ledListA, ledListB, link, linkHId, linkHIds, linkIdx, links, nodeLed, nodeListHeaderText, outText, _i, _j, _k, _len, _len1, _len2, _ref;
    outText = "";
    links = (function() {
      var _i, _len, _ref, _results;
      _ref = spideyGeomToExport.links;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        link = _ref[_i];
        if (link.source === node.name) {
          _results.push(link);
        }
      }
      return _results;
    })();
    linkHIds = [];
    for (linkIdx = _i = 0, _len = links.length; _i < _len; linkIdx = ++_i) {
      link = links[linkIdx];
      linkHId = "__spideyLink_" + link.source + "_" + link.target;
      linkHIds.push(linkHId);
      if (link.padEdges.length !== 2) {
        console.log("Link PadEdges != 2 === " + link.padEdges.length + " for link from " + link.source + " to " + link.target);
      }
      ledListA = this.convLedListToMbedSeq(link.padEdges[0]);
      ledListB = this.convLedListToMbedSeq(link.padEdges[1]);
      outText += "static const SpideyLinkInfo " + linkHId + " =\n{\n	" + link.source + ",\n	" + link.target + ",\n	" + ledListA[0] + ",\n	" + ledListA[1] + ",\n	" + ledListB[0] + ",\n	" + ledListB[1] + "\n};\n";
    }
    nodeListHeaderText = "\t{\n	\t" + node.ledIdxs.length + ",\n	\t{";
    _ref = node.ledIdxs;
    for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
      nodeLed = _ref[_j];
      nodeListHeaderText += " " + nodeLed + ", ";
    }
    nodeListHeaderText += "},\n\t\t" + linkHIds.length + ",\n\t\t{";
    for (_k = 0, _len2 = linkHIds.length; _k < _len2; _k++) {
      linkHId = linkHIds[_k];
      nodeListHeaderText += " &" + linkHId + ", ";
    }
    nodeListHeaderText += "	}\n\t},\n";
    return [nodeListHeaderText, outText, linkHIds];
  };

  spideyGeom.prototype.convertNodesToMbedHeader = function(spideyGeomToExport) {
    var linkHId, linkHIdsList, linkHid, node, nodeLine, nodeListHeaderText, nodeTexts, outLine, outText, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1;
    outText = "";
    outLine = "\n// Spidey Node Information Elements\n\nconst int MAX_SPIDEY_NODE_LEDS = 4;\nconst int MAX_SPIDEY_NODE_LINKS = 6;\nconst int MAX_SPIDEY_LINK_ELS = 4;\n\nstruct SpideyLinkInfo\n{\n	int fromNode;\n    int toNode;\n    int edgeLengthA;\n    int edgeLedsA[MAX_SPIDEY_LINK_ELS];\n    int edgeLengthB;\n    int edgeLedsB[MAX_SPIDEY_LINK_ELS];\n};\n\nstruct SpideyNodeInfo\n{\n	int numNodeLeds;\n    int nodeLeds[MAX_SPIDEY_NODE_LEDS];\n    int numLinks;\n    const SpideyLinkInfo* nodeLinks[MAX_SPIDEY_NODE_LINKS];\n};\n\n";
    nodeListHeaderText = [];
    linkHIdsList = [];
    _ref = spideyGeomToExport.nodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      node = _ref[_i];
      nodeTexts = this.convNodeToMbedSeq(node, spideyGeomToExport);
      nodeListHeaderText.push(nodeTexts[0] + "\n");
      outLine += nodeTexts[1] + "\n";
      _ref1 = nodeTexts[2];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        linkHId = _ref1[_j];
        linkHIdsList.push(linkHId);
      }
    }
    outLine += "\n// List of Spidey Wall nodes\n\nstatic const SpideyNodeInfo _spideyNodes[] = \n{\n";
    for (_k = 0, _len2 = nodeListHeaderText.length; _k < _len2; _k++) {
      nodeLine = nodeListHeaderText[_k];
      outLine += nodeLine;
    }
    outLine += "};\n";
    outText += outLine;
    outLine = "\nconst static SpideyLinkInfo* _spideyLinks[] =\n{\n";
    for (_l = 0, _len3 = linkHIdsList.length; _l < _len3; _l++) {
      linkHid = linkHIdsList[_l];
      outLine += "\t&" + linkHid + ",\n";
    }
    outLine += "};";
    outText += outLine;
    return outText;
  };

  spideyGeom.prototype.convertToMbedHeader = function(spideyGeomToExport) {
    var outText;
    outText = "// Header file generated by SpideySim HTML\n// Rob Dobson, 2015\n\n";
    outText += this.convertPadsToMbedHeader(spideyGeomToExport);
    outText += this.convertNodesToMbedHeader(spideyGeomToExport);
    return outText;
  };

  spideyGeom.prototype.showDownloadJsonLink = function() {
    var node, spideyGeomJson, spideyGeomMbed;
    this.spideyGeomFinal = {
      leds: this.getLedsExportInfo(),
      pads: this.getPadsExportInfo(),
      links: this.getLinkExportInfo(),
      nodes: (function() {
        var _i, _len, _ref, _results;
        _ref = this.spideyGraph.nodeList;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          node = _ref[_i];
          _results.push(this.getNodeExportInfo(node));
        }
        return _results;
      }).call(this)
    };
    spideyGeomJson = "text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(this.spideyGeomFinal, function(key, val) {
      if (val.toFixed) {
        return Number(val.toFixed(2));
      } else {
        return val;
      }
    }));
    $('<a href="data:' + spideyGeomJson + '" download="SpideyGeometry.json">Download Spidey JSON</a>').appendTo('#downloadSpideyJson');
    spideyGeomMbed = "text/text;charset=utf-8," + encodeURIComponent(this.convertToMbedHeader(this.spideyGeomFinal));
    return $('<a href="data:' + spideyGeomMbed + '" download="SpideyGeometry.h">Download Spidey MBED</a>').appendTo('#downloadSpideyMbed');
  };

  return spideyGeom;

})();
